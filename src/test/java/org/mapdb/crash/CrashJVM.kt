package org.mapdb.crash

import org.junit.*
import org.junit.Assert.assertTrue
import org.mapdb.TT
import org.mapdb.TT.assertFailsWith
import org.mapdb.util.DataIO
import java.io.*

/**
 * Runs custom code in forked JVM, and verify if data survive JVM crash.
 * JVM crash is generated by `kill PID -9` or using Unsafe set invalid memory
 */
abstract class CrashJVM {

    private var testDir: File? = null
    private var seedEndDir: File? = null
    private var seedStartDir: File? = null

    fun setTestDir(tempDir: File) {
        this.testDir = tempDir
        this.seedEndDir = File(tempDir, "seedEndDir")
        this.seedStartDir = File(tempDir, "seedStartDir")
        assertTrue(seedEndDir!!.isDirectory)
        assertTrue(seedStartDir!!.isDirectory)

    }
    fun getTestDir(): File = testDir!!;


    @Before fun init(){
        val testDir = File.createTempFile("mapdb", "jvmCrashTest")

        testDir.delete()
        testDir.mkdirs()
        val seedEndDir = File(testDir, "seedEndDir")
        seedEndDir.mkdirs()
        val seedStartDir = File(testDir, "seedStartDir")
        seedStartDir.mkdirs()
        setTestDir(testDir);
    }

    @After fun delete(){
        TT.tempDelete(testDir?:return);
    }

    abstract fun doInJVM(startSeed: Long, params:String)


    abstract fun verifySeed(startSeed:Long, endSeed: Long, params:String):Long



    fun startSeed(seed: Long) {
        File(seedStartDir, "" + seed).createNewFile()
    }


    fun commitSeed(seed: Long) {
        File(seedEndDir, "" + seed).createNewFile()
    }



    companion object {

        @SuppressWarnings("restriction")
        protected fun getUnsafe(): sun.misc.Unsafe {
            val singleoneInstanceField = sun.misc.Unsafe::class.java.getDeclaredField("theUnsafe")
            singleoneInstanceField.isAccessible = true
            val ret = singleoneInstanceField.get(null) as sun.misc.Unsafe
            return ret
        }


        internal fun findHighestSeed(seedDir: File): Long {
            var ret: Long = -1
            for (child in seedDir.listFiles()!!) {
                val num = java.lang.Long.parseLong(child.name)
                ret = Math.max(ret, num)
                child.delete()
            }
            return ret
        }

        @JvmStatic fun main(args: Array<String>) {
            print("started_")
            try {
                assertTrue("need args", args.size == 5)
                val testClass = args[0]
                val test = Class.forName(testClass).newInstance() as CrashJVM

                val tempDir = File(args[1])
                assertTrue(tempDir.isDirectory)
                test.setTestDir(tempDir)

                val killDelay = args[2].toLong()
                val t = Thread({
                    Thread.sleep(killDelay)
                    killThisJVM()
                })
                t.isDaemon = true
                t.start();

                val startSeed = args[3].toLong()
                val params = args[4]
                test.doInJVM(startSeed, params)
                System.err.println("Failure, method quitNatural exit")
                System.exit(182)

            } catch (e: Throwable) {
                e.printStackTrace()
                System.exit(188)
            }
        }

        internal fun killThisJVM() {
            val pid = File("/proc/self").canonicalFile.name

            java.lang.Long.valueOf(pid)
            print("killed")

            try {
                try {
                    //use unsafe to exit
                    getUnsafe().putAddress(0, 0);
                }finally{
                    //Linux specific way
                    val b = ProcessBuilder("kill", "-9", pid)
                    b.start()
                    Thread.sleep(10000)
                    //fallback into common method
                }
            }finally {
                //all previous ways to kill JVM failed, fallback
                println("KILL - Still alive")
                System.exit(-11123121);
            }
        }


        internal fun jvmExecutable(): String {
            val exec = if (System.getProperty("os.name").startsWith("Win"))
                    "java.exe"
                else
                    "java"
            val javaHome = System.getProperty("java.home")
            if (javaHome == null || "" == javaHome)
                return exec
            return javaHome + File.separator + "bin" + File.separator + exec
        }

        internal fun outStreamToString(`in`: InputStream): String {
            val out = ByteArrayOutputStream()
            var b = `in`.read()
            while (b != -1) {
                out.write(b)
                b = `in`.read()
            }
            return String(out.toByteArray())
        }


        fun run(test: CrashJVM, killDelay: Long=500, time: Long=60*1000, params:String="") {

            val endTimestamp = System.currentTimeMillis() + time

            var seed = 0L;
            while (System.currentTimeMillis() < endTimestamp) {
                val b = ProcessBuilder(
                        jvmExecutable(),
                        "-classpath",
                        System.getProperty("java.class.path"),
                        CrashJVM::class.java.name,
                        test.javaClass.name,
                        test.testDir!!.getAbsolutePath(),
                        "" + killDelay,
                        "" + seed,
                        params)
                val pr = b.start()
                pr.waitFor() //it should kill itself after some time

                Thread.sleep(100)// just in case

                //handle output streams
                val out = outStreamToString(pr.inputStream)

                val err = outStreamToString(pr.errorStream);
                if(err.length>0) {
                    System.err.print("\n=====FORKED JVM START=====\n" +
                            err +
                            "\n======FORKED JVM END======\n")
                }
                assertTrue(out, out.startsWith("started_"))
                assertTrue(out, out.endsWith("_killed") || (out.contains("_killed#") && out.contains("# A fatal error has been detected")))
                //try to delete crash log file
                if(out.contains("_killed#")){
                    val s = out.split(".log").first().split("#").last().trim()
                    File(s+".log").delete()
                }


                assertTrue(pr.exitValue()==134 || 137==pr.exitValue())

                // handle seeds
                val startSeed = findHighestSeed(test.seedStartDir!!)
                val endSeed = findHighestSeed(test.seedEndDir!!)

                if(endSeed!=-1L)
                    seed = test.verifySeed(startSeed, endSeed, params);
            }
        }
    }

}


class CrashJVMTestFail: CrashJVM(){

    override fun verifySeed(startSeed: Long, endSeed: Long, params:String): Long {
        val f = File(getTestDir(), "aaa")
        val seed = f.inputStream().use {
            DataIO.unpackLong(it)
        }
        assertTrue(seed>=startSeed)
        assertTrue(endSeed==-1L && seed<=endSeed)
        return seed+1
    }

    override fun doInJVM(startSeed: Long, params:String) {
        val f = File(getTestDir(), "aaa")
        var seed = startSeed;

        while(true){
            seed++
            startSeed(seed)
            f.outputStream().use {
                DataIO.packLong(it, seed)
            }
            commitSeed(seed)
        }
    }


    @Test fun test(){
        assertFailsWith(Throwable::class.java, {
            run(this, time = 2000, killDelay = 200)
        })
    }

}


class CrashJVMTest: CrashJVM(){

    var verifyCalled = 0L
    override fun verifySeed(startSeed: Long, endSeed: Long, params:String): Long {
        verifyCalled++
        for(seed in startSeed .. endSeed){
            assertTrue(File(getTestDir(), "" + seed).exists())
        }

        return Math.max(startSeed,endSeed)+1;
    }

    override fun doInJVM(startSeed: Long, params:String) {
        var seed = startSeed;

        while(true){
            seed++
            startSeed(seed)
            val f = File(getTestDir(), "" + seed)
            f.createNewFile()
            commitSeed(seed)
        }
    }

    @Test
    fun test(){
        if(TT.shortTest())
            return

        val runtime = 4000L + TT.testScale()*60*1000;
        val start = System.currentTimeMillis()
        run(this, time=runtime, killDelay = 200)
        assertTrue(System.currentTimeMillis()-start >= runtime)
        assertTrue(verifyCalled>0)
    }
}
